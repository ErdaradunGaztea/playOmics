---
title: "R Notebook"
output: html_notebook
---

```{r message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(readxl)
library(data.table)
# library(dtplyr)

```


```{r message=FALSE, warning=FALSE, include=FALSE}
functions <- dir("R", full.names = T, recursive = T)
lapply(functions, source)
```


# Construct data object (list of dataframes)

```{r}
clinical_data <-
  read_excel("~/code/test_data/TCGA-LAML/csv/clinical_data.xlsx", na = c("NA", "NA,NA")) %>% 
  data.table::transpose(keep.names="ID", make.names="attrib_name") %>% 
  select(-"overallsurvival") %>% 
  mutate_at(.vars = c("years_to_birth", "overall_survival"), as.numeric) %>% 
  mutate_at(.vars = c("gender", "race", "ethnicity", "status"), as.factor)

met_HM27 <-
  read_excel("~/code/test_data/TCGA-LAML/csv/Methylation (Gene level, HM27).xlsx", na = c("NA", "NA,NA")) %>% 
  transpose(keep.names="ID", make.names="attrib_name") %>% 
  mutate_at(vars(-ID), as.numeric)

met_HM450K <-
  read_excel("~/code/test_data/TCGA-LAML/csv/Methylation (Gene level, HM450K).xlsx", na = c("NA", "NA,NA")) %>% 
  transpose(keep.names="ID", make.names="attrib_name") %>% 
  mutate_at(vars(-ID), as.numeric)

miRNA <-
  read_excel("~/code/test_data/TCGA-LAML/csv/miRNA (Gene level).xlsx", na = c("NA", "NA,NA")) %>% 
  transpose(keep.names="ID", make.names="attrib_name") %>% 
  mutate_at(vars(-ID), as.numeric)

mutation <-
  read_excel("~/code/test_data/TCGA-LAML/csv/Mutation (Gene level).xlsx", na = c("NA", "NA,NA")) %>% 
  transpose(keep.names="ID", make.names="attrib_name") %>% 
  mutate_at(vars(-ID), as.numeric)

RNAseq <-
  read_excel("~/code/test_data/TCGA-LAML/csv/RNAseq (HiSeq, Gene level).xlsx", na = c("NA", "NA,NA")) %>% 
  transpose(keep.names="ID", make.names="attrib_name") %>% 
  mutate_at(vars(-ID), as.numeric)

SCNV_log_ratio <-
  read_excel("~/code/test_data/TCGA-LAML/csv/SCNV (Focal level, log-ratio).xlsx", na = c("NA", "NA,NA")) %>% 
  transpose(keep.names="ID", make.names="attrib_name") %>% 
  mutate_at(vars(-ID), as.numeric)

LAML_data <- connect_datasets(clinical_data, met_HM27, met_HM450K, miRNA, mutation, RNAseq, SCNV_log_ratio)
```

# Check coverage between datasets

```{r}
plot_coverage(LAML_data)
```

```{r}
data_summary(LAML_data)
```


# Data overview

```{r}
my_overview <- data_overview(LAML_data$miRNA)
# View(overview)
present_numeric_overview(my_overview)
my_overview
```
```{r}
plot_density_numeric(LAML_data$SCNV_log_ratio)
LAML_data$SCNV_log_ratio <-
  data_thresholding(LAML_data$SCNV_log_ratio, 0.1, 0.1)
```

```{r}
data_overview(LAML_data$clinical_data)
```
WE MIGHT PREDICT STATUS (0/1) or overall survival (e.g. <1y, >1y) 

```{r}
# library(tidymodels)

# LAML_data_filter <-
# LAML_data %>% 
#   lapply(function(data){
#    to_remove <- caret::nearZeroVar(data)
#    if(length(to_remove) >0){
#     data <- data[, -to_remove]
#    } else data
#     }) 
```

```{r}
data_summary(LAML_data_filter)
```

```{r}
plot_density_numeric(LAML_data_filter$miRNA)
```

```{r}
plot_density_numeric(data_thresholding(LAML_data_filter$miRNA, 1, 0.75))
```

```{r}
LAML_data[["RNAseq"]] <- data_thresholding(LAML_data[["RNAseq"]], 3, 0.5)
```

# Target definition

```{r}
target <-
  define_target(phenotype_df = "clinical_data",
              target_variable = "status",
              id_variable = "ID",
              positive_class_indication = "1")
```

# Feature selection

```{r}
LAML_data_prepared <-
  add_target(data = LAML_data,
             target = target)
```

```{r}
library(mlr3verse)
```
> https://mlr3book.mlr-org.com/optimization.html#fs

> An external algorithm computes a rank of the features (e.g. based on the correlation to the response). Then, features are subsetted by a certain criteria, e.g. an absolute number or a percentage of the number of variables.
> Filter methods assign an importance value to each feature. Based on these values the features can be ranked. 

```{r}
library("mlr3")
library("mlr3filters")
library("mlr3learners")
set.seed(1)

mydata <- LAML_data_prepared[["miRNA"]]
#zamienic kategoryczne zmienne na liczbowe
# do przeniesienia do funkcji
names(mydata) <- make.names(names(mydata))

task = as_task_classif(mydata, target = "status", positive = "1")
filter = flt("mrmr")
#parallel
as.data.table(filter$calculate(task))
```

### Pararelization delivered by mlr3 pck

```{r}
filters = flts(c("variance", "mrmr"))

# set threads for all filters which support it
set_threads(filters, n = 4)

as.data.table(filters[[1]]$calculate(task))
as.data.table(filters[[2]]$calculate(task))
```


```{r}
mydata <- LAML_data_prepared[["RNAseq"]]
names(mydata) <- make.names(names(mydata))

task = as_task_classif(mydata, target = "status", positive = "1")
filter = flt("anova")
# set threads for all filters which support it
set_threads(filter, n = 10)
filter_cor$param_set$values = list(filter.frac = 0.5) # works in mlr3pipeline
#parallel
as.data.table(filter$calculate(task))
```
After a long time it returns the results!

```{r}
LAML_data_filtered <- 
  select_variables(LAML_data_prepared, target, "auc", cutoff_method = "top_n", cutoff_treshold = 30)

# filtrowanie w oparciu o CV lub train/test split - "how not to perform cross-validation"
```

> TO-DO: Error: Task 'mydata' has the following unsupported feature types: factor, character -> SOLVED

## Variable (feature) importance filters

> All Learner with the property “importance” come with integrated feature selection methods.

> 42 classif learners in the mlr3 package

```{r}
# remotes::install_github("mlr-org/mlr3extralearners")
library(mlr3extralearners)
list_mlr3learners(
  select = c("id", "properties", "predict_types"),
  filter = list(class = "classif")) %>% View()
```

Among those 9 has importance properties and therefore might be used for variable importance filters:

```{r}
list_mlr3learners(
  select = c("id", "properties", "predict_types"),
  filter = list(class = "classif", properties = "importance")) 
```


```{r}
lrn = lrn("classif.ranger")
lrn$param_set$values = list(importance = "impurity")

filter = flt("importance", learner = lrn)
filter$calculate(task)
as.data.table(filter)
```
Variable importance filters work faster than filtering.

> Logging!!!

# Modeling

## Recreation of logistic regression

> UPS! Patients' code needed at this moment to connect (reduce) datasets

```{r}
library(tidymodels)

create_multiple_models(LAML_data_filtered)

create_one_model(LAML_data_filtered, target)
```


## More advanced

> TO-DO: Resampling; class balancing

```{r}
library(mlr3tuning)
```


```{r}
learners = list(
  learner_logreg = lrn("classif.log_reg", predict_type = "prob",
    predict_sets = c("train", "test")),
  learner_lda = lrn("classif.lda", predict_type = "prob",
    predict_sets = c("train", "test")),
  learner_qda = lrn("classif.qda", predict_type = "prob",
    predict_sets = c("train", "test")),
  learner_nb = lrn("classif.naive_bayes", predict_type = "prob",
    predict_sets = c("train", "test")),
  learner_knn = lrn("classif.kknn", scale = FALSE,
    predict_type = "prob"),
  learner_rpart = lrn("classif.rpart",
    predict_type = "prob"),
  learner_rf = lrn("classif.ranger", num.trees = 1000,
    predict_type = "prob")
)
```

> Tests!! unit test

> Gitlab CI/CD

# Explainability
